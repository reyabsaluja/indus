interface GeminiMessage {
  role: 'user' | 'model' | 'system';
  parts: { text: string }[];
}

interface GeminiStreamChunk {
  candidates?: Array<{
    content?: {
      parts?: Array<{ text?: string }>;
    };
    finishReason?: string;
  }>;
}

export class GeminiClient {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateStreamingContent(messages: GeminiMessage[]): Promise<ReadableStream<Uint8Array>> {
    const model = 'gemini-1.5-flash';
    const url = `${this.baseUrl}/models/${model}:streamGenerateContent?key=${this.apiKey}`;

    // Convert system message to user message for Gemini (it doesn't have system role)
    const geminiMessages = messages.map(msg => {
      if (msg.role === 'system') {
        return {
          role: 'user' as const,
          parts: [{ text: `[SYSTEM INSTRUCTIONS]\n${msg.parts[0].text}` }]
        };
      }
      return {
        role: msg.role === 'user' ? 'user' as const : 'model' as const,
        parts: msg.parts
      };
    });

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: geminiMessages,
        generationConfig: {
          temperature: 0.1,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 2048,
        },
        safetySettings: [
          {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_MEDIUM_AND_ABOVE'
          }
        ]
      }),
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    return response.body!;
  }

  async generateContent(messages: GeminiMessage[]): Promise<string> {
    const model = 'gemini-1.5-flash';
    const url = `${this.baseUrl}/models/${model}:generateContent?key=${this.apiKey}`;

    // Convert system message to user message for Gemini
    const geminiMessages = messages.map(msg => {
      if (msg.role === 'system') {
        return {
          role: 'user' as const,
          parts: [{ text: `[SYSTEM INSTRUCTIONS]\n${msg.parts[0].text}` }]
        };
      }
      return {
        role: msg.role === 'user' ? 'user' as const : 'model' as const,
        parts: msg.parts
      };
    });

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: geminiMessages,
        generationConfig: {
          temperature: 0.1,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 2048,
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
      return data.candidates[0].content.parts[0].text;
    }

    throw new Error('No content generated by Gemini');
  }

  static parseStreamChunk(chunk: string): string | null {
    try {
      const data: GeminiStreamChunk = JSON.parse(chunk);
      return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
    } catch {
      return null;
    }
  }
} 